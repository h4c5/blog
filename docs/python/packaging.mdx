---
id: packaging-python
slug: packaging-python
title: Packager son code python
description: Packager son code python en 2023 avec pyproject.toml
date: "2023-03-04"
tags:
    - python
    - packaging
    - setuptools
    - pyproject.toml
    - setup.py
    - setup.cfg
    - poetry
    - pipenv
---

import Giscus from "@site/src/components/Giscus.js";
import TOCInline from "@theme/TOCInline";

:::note Disclaimer

Les informations et conclusions de cet article sont bas√©es sur mes propres analyses et
interpr√©tations, elles ne sont pas enti√®rement fiables. Je vous invite √† vous
r√©f√©rer aux sources originelles et √† me faire vos retour en commentaire.

Encore mieux, n'h√©sitez √† proposer directement des
[modifications sur Github](https://github.com/h4c5/blog/edit/main/docs/python/packaging.mdx) üòâ

:::

Packager son code, c'est l'emballer dans un joli paquet afin que d'autres personnes puisse le r√©utiliser üéÅ.

Il s'agit d'un concept tr√®s important. A chaque fois que vous faites `pip install unpackage` ou `import unpackage`,
vous utilisez des paquets que d'autres ont emball√© pour vous.

Alors comment √ßa marche ? Ne pourrait-on pas se contenter de se partager notre code avec git ? Et bien, c'est plus
complexe qu'il n'y para√Æt. En fait il y a tout un groupe de travail, la
[Python Packaging Authority](https://github.com/pypa) (alias pypa), qui bosse dessus
[depuis 2011](https://www.pypa.io/en/latest/history/#before-2013).

Dans cette article, on fera un rapide tour d'horizon du packaging en python et on pr√©sentera une m√©thode simple pour
packager son code en 2023.

## Sommaire

<TOCInline toc={toc.filter((node) => node.id !== "sommaire")} />

## Les packages en python

D'abord quelques d√©finition :

### Module python

Un [_module_](https://docs.python.org/fr/3/tutorial/modules.html) python un est fichier texte dont l'extension est `.py`
et qui contient du code python.

On appelle cela _module_ car python permet d'importer les √©l√©ments d√©finis dans les fichiers `.py`, ce qui √©vite de
devoir mettre tout son code dans un seul gros fichier.

Par exemple si l'on cr√©e un fichier `count_lines.py` qui contient une fonction `count_lines_file` il est ensuite
possible d'importer cette fonction :

```python title="count_lines.py"
def count_lines_file(filepath: str) -> int:
    """Count the number of lines in a file"""
    return sum(1 for _ in open(filepath))
```

```python
from count_lines import count_lines_file
count_lines_file("count_lines.py")
3
```

Lorsque l'on execute l'instruction `from count_lines import count_lines_file`, python cherche le module
dans le r√©pertoire courant (l√† o√π python a √©t√© lanc√©) ; puis dans le r√©pertoire d'installation de python
`/usr/lib/python3.11` ; puis dans le r√©pertoire o√π python installe les packages par d√©faut :
`/usr/lib/python3.11/site-packages`.

D√®s que le module est trouv√©, il est ex√©cut√© dans l'environnement python et les √©l√©ments qui y sont d√©finis deviennent
disponibles.

La liste des r√©pertoires dans lequel python cherche les modules est gr√¢ce au package `sys` :

```python
import sys
sys.path
["", "/usr/lib/python3.11/python311.zip", "/usr/lib/python3.11/python311", "/usr/lib/python3.11/site-packages"]
```

### Package python

Un [_package_](https://docs.python.org/fr/3/tutorial/modules.html#packages) est un dossier qui regroupe un ensemble de
modules python et qui facilite leur acc√®s en cr√©ant un espace de nommage :
`from numpy.linalg import norm`.

Pour cr√©er un package, il suffit de cr√©er un fichier `__init__.py` (qui peut tout a fait √™tre vide) dans un dossier.
Le dossier est alors consid√©r√© par python comme un package.

Cr√©ons un package pour le module `count_lines.py` :

```
count_package
‚îú‚îÄ‚îÄ __init__.py
‚îî‚îÄ‚îÄ count_lines.py
```

A pr√©sent on peut utiliser la notation "point√©e" pour importer le module `count_lines` :

```python
from count_package.count_lines import count_lines_file
count_lines_file("count_lines.py")
3
```

Lorsque l'on execute l'instruction `from count_package.count_lines import count_lines_file`, python cherche un dossier
`count_package` contenant un fichier `__init__.py` dans les r√©pertoires de `sys.path` (le r√©pertoire courant et les
r√©pertoires par d√©faut vus plus haut).

Si le package est trouv√©, les modules qui y sont pr√©sents sont accessibles via la notation "point√©e".

## Distribuer son package

Pour distribuer son package on cr√©e une _distribution_. Il s'agit d'une archive contenant le package √† distribuer et qui
pourra ensuite √™tre install√© avec le gestionnaire de paquet _pip_.

Il en existe deux formats de distributions principaux :

-   Le format [_Source Distribution_](https://packaging.python.org/en/latest/glossary/#term-Source-Distribution-or-sdist)
    (sdist) : il s'agit d'une archive contenant l'ensemble du code source et des m√©tadonn√©es

-   Le format [_Built Distribution_](https://packaging.python.org/en/latest/glossary/#term-Built-Distribution) :
    il s'agit d'un format de distribution o√π un certain nombre de choses ont √©t√© pr√©-compil√©es pour faciliter
    l'installation sur d'autres environnement. C'est notamment utile pour les modules √©crits en C / C++.

Le format `wheel` est le format de type _Built Distribution_ de r√©f√©rence. Il s'agit du format d√©velopp√© par la Python
Packaging Authority et qui est tr√®s souvent utilis√© pour distribuer les packages.

Le workflow de distribution ressemble sch√©matiquement √† √ßa :

```mermaid
flowchart LR
    A[Code source local] --> B("distribution (sdist, wheel)")
    B --> C[Index de paquets python]
    C --> D[t√©l√©chargement et installation]
```

Il existe de nombreux outils pour cr√©er des distributions mais aujourd'hui on se focalisera principalement sur les
outils cr√©√©s par la Python Packaging Authority et qui sont devenus des incontournables, √† savoir `setuptools`, `build`
et `twine`.

### setuptools

[`setuptools`](https://setuptools.pypa.io/en/latest/index.html) est l'outil utilis√© par la grande majorit√© des projets
pour construire leurs distributions.

Reprenons notre exemple `count_package` de tout √† l'heure et voyons comment cr√©er une distribution avec `setuptools`.

L'arborescence de notre projet pourrait ressembler √† √ßa :

```
projet_genial
‚îú‚îÄ‚îÄ count_package
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ count_lines.py
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îî‚îÄ‚îÄ test_count_lines.py
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE.md
‚îî‚îÄ‚îÄ README.md
```

Si on ne lui dit pas, `setuptools` n'a aucun moyen de savoir quels sont les fichiers et repertoires qui doivent √™tre
inclus dans notre distribution. Il ne peut pas non plus deviner notre adresse mail, le nom de notre projet, sa version,
etc.

`setuptools` a donc besoin d'un fichier de configuration qui lui permettra de savoir quoi inclure dans la distribution.

L√† on √ßa devient rigolo c'est qu'il y a trois types de fichiers de configuration possible pour setuptools (et ils sont
non mutuellement exclusifs) :

-   Le fichier `setup.py`, le plus ancien et le plus populaire
    ([3.7 millions de r√©sultats sur github](https://github.com/search?q=filename%3Asetup.py))
-   Le fichier `setup.cfg`, le second venu et qui a fait de
    [nombreux et nombreuses adeptes](https://sametmax2.com/vive-setup-cfg-et-mort-a-pyproject-toml/index.html)
    ([0.4 millions de r√©sultats sur github](https://github.com/search?q=filename%3Asetup.py))
-   Le fichier `pyproject.toml`, le dernier venu et qui est √† pr√©sent le standard officiel pour tous les outils de
    packaging python.
    ([0.2 millions de r√©sultats sur github](https://github.com/search?q=filename%3Asetup.py))

`pyproject.toml` est aujourd'hui le [standard officiel](https://peps.python.org/pep-0621/) mais reste encore tr√®s
minoritaire par rapport √† `setup.py`, c'est pourquoi nous aborderons les trois formats de fichier.

### setup.py

Le fichier `setup.py` comme son extension le laisse penser est un fichier python. Il a la forme suivante :

```python title="setup.py"
from setuptools import setup

setup(
    name='count_package',
    author='me',
    description='Package for counting the number of lines in files.'
    version='0.0.1',
    python_requires='>=3.7, <4',
    install_requires=[
        'pandas',
        'importlib-metadata; python_version >= "3.8"',
    ],
)
```

Le fait qu'il s'agisse d'un fichier python fait √† la fois sa force et sa faiblesse : il est possible de construire la
configuration dynamiquement dans le code mais √ßa rend la configuration difficile √† parser et √† interfacer avec d'autres
outils externes.

Puisqu'il s'agit d'un format propre √† `setuptools` les distributions de type _sdist_ ne seront installables que si
setuptools a bien √©t√© install√© sur l'environnement cible et dans une version compatible.

De plus puisque l'immense majorit√© des projets se sont mis √† utiliser setuptools et `setup.py` il est devenu difficile
de proposer des alternatives et des projets comme [flit](https://pypi.org/project/flit/) on d√ª √™tre construit "par
dessus" `setuptools`, ce qui ne favorise pas l'innovation.

Par ailleurs son utilisation est souvent probl√©matique. Pour reprendre l'exemple de
[cet article](https://bernat.tech/posts/pep-517-518/#packaging-tool-diversity), vous pourriez par exemple √™tre tent√© de
d'introduire une condition _if/else_ dans votre `setup.py` pour g√©rer une d√©pendance n√©cessaire en python 2.7 en vous
basant sur `sys.version` mais ce faisant vous introduiriez un bug vicieux : la d√©pendance sera embarqu√©e ou non en
fonction de l'environnement qui compile la distribution de votre package et non pas en fonction de l'environnement de
l'utilisateur qui l'installe.

Il est aussi tentant
[d'importer le package depuis `setup.py`](https://bernat.tech/posts/growing-pain/#importing-the-built-package-from-within-setuppy)
pour g√©rer la version sa version par exemple. Ce qui fera planter les distributions sdist.

Aujourd'hui l'utilisation de `setup.py` est possible mais il est conseill√© de privil√©gier une utilisation d√©clarative.
De plus l'utilisation du fichier comme script : `python setup.py` est **d√©pr√©ci√©** comme l'indique la documentation de
setuptools :

> It is important to remember, however, that running this file as a script (e.g. python setup.py sdist) is strongly
> discouraged, and that the majority of the command line interfaces are (or will be) deprecated (e.g. python setup.py
> install, python setup.py bdist_wininst, ‚Ä¶).
>
> We also recommend users to expose as much as possible configuration in a more declarative way via the pyproject.toml
> or setup.cfg, and keep the setup.py minimal with only the dynamic parts (or even omit it completely if applicable).
>
> See [Why you shouldn‚Äôt invoke setup.py directly](https://blog.ganssle.io/articles/2021/10/setup-py-deprecated.html)
> for more background.

### setup.cfg

Pour r√©pondre aux probl√®mes mentionn√©s ci-dessus et rendre la configuration plus d√©clarative, la pypa a cr√©√© en 2016 le
format de fichier `setup.cfg`.

Le fichier `setup.py` d'exemple plut haut est √©quivalant au fichier `setup.cfg` suivant :

```cfg title="setup.cfg"
[metadata]
name = count_package
version = 0.0.1
author = me
description = Package for counting the number of lines in files.


[options]
python_requires = >=3.7,<4
install_requires =
    pandas
    importlib-metadata; python_version >= "3.8"
```

Ce format a fait de
[nombreuses et nombreux adeptes](https://sametmax2.com/vive-setup-cfg-et-mort-a-pyproject-toml/index.html) mais a
r√©cemment √©t√© supplant√© par le format `pyproject.toml` qui est dor√©navant le moyen officiel de d√©clarer la configuration
des packages python.

### pyproject.toml

Le format `pyproject.toml` en plus de reprendre l'approche d√©clarative de `setup.cfg`, introduit sont lot de nouveaut√©.
Il est d√©sormais possible (et m√™me obligatoire) de sp√©cifier le builder du package. Il est √©galement un moyen de
centraliser les configuration de nombreux outils de d√©veloppement de fa√ßon agnostique plut√¥t que de multiplier les
fichiers de configuration du type `tox.ini`, `.coveragerc`, etc.

A propos du builder : comme je le faisais remarquer plus haut, lorsqu'un package est distribu√© sous format sdist, c'est
le client qui doit construire le package. Lorsqu'il ex√©cute la commande `pip install count_package`, pip doit donc
r√©cup√©rer la distribution sdit, puis construire le package √† partir de la configuration qu'il s'y trouve.
Comment pip fait-il pour savoir quelle configuration utiliser ? Et comment utiliser un autre builder que `setuptools`
√† ce moment l√† ?

Pour r√©pondre √† cette probl√©matique, le format `pyproject.toml` inclus une section obligatoire pour d√©finir le builder
qui doit √™tre utilis√© pour construire le package :

```toml tile="pyproject.toml"
[build-system]
requires = [
  "setuptools>=44",
  "wheel>=0.30.0",
  "cython>=0.29.4",
]
build-backend = "setuptools.build_meta"
```

Avec `pyproject.toml` il est d√©sormais possible de d√©clarer √† `pip` les d√©pendances n√©cessaire au build !

Il est alors tout √† fait possible de sp√©cifier l'utilisation d'un autre builder que setuptools, tel que flit :

```toml tile="pyproject.toml"
[build-system]
requires = ["flit"]
build-backend = "flit.api:main"
```

Ce format est en train de s'imposer petit √† petit comme le moyen de centraliser la configuration du package. Il est
[le format privil√©gi√© par setuptools](https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html) et un
certains nombres d'outils tiers l'utilise pour stocker leur configuration :
[black](https://black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html#what-on-earth-is-a-pyproject-toml-file),
[pytest](https://docs.pytest.org/en/7.2.x/reference/customize.html),
[isort](https://pycqa.github.io/isort/docs/configuration/config_files.html#pyprojecttoml-preferred-format),
etc.

Voici un exemple de fichier `pyproject.toml` pour notre package d'exemple `count_package` :

```toml tile="pyproject.toml"
[build-system]
requires = ["setuptools"]
build-backend = "setuptools.build_meta"

[project]
name = "count_package"
version = "0.0.1"
description = "Package for counting the number of lines in files."
name = "my_package"
authors = [
    {name = "me", email = "email@me.fr"},
]
requires-python = ">=3.8,<4"
dependencies = [
    "pandas",
    'importlib-metadata; python_version >= "3.8"',
]
dynamic = ["version"]
```

La [documentation de setuptools](https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html) donne plus de
d√©tails la configuration au format `pyproject.toml`

### Construire une distribution de son package

Une fois le fichier de configuration (de pr√©f√©rence `pyproject.toml`) √©crit, il ne vous reste plus qu'√† construire votre
package.

Pour √ßa, le moyen moderne de proc√©der et d'utiliser le package [`build`](https://pypi.org/project/build) d√©velopp√© par
la pypa :

```bash
pip install --upgrade build
python -m build
```

`build` commencera par installer le builder sp√©cifi√© dans votre fichier `pyproject.toml` puis l'utilisera pour
construire une distribution sdist et une wheel.

Vous pourrez ensuite utiliser le package [`twine`](https://twine.readthedocs.io/en/stable/) pour le publier sur le
repository officiel [pypi](https://pypi.org/).

:::info

Pour des raisons de r√©tro-compatibilit√© avec les anciennes versions des librairies de packaging,
[vous pouvez cr√©er un fichier `setup.py` minimal](https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html)
en plus du fichier `pyproject.toml` :

```python title="setup.py"
from setuptools import setup

setup()
```

:::

## Le layout

Lors de la configuration de votre package, peut importe la m√©thode utilis√©e (`setup.py`, `setup.cfg` ou
`pyproject.toml`), vous devez sp√©cifier les packages **et les sous-packages** que vous souhaitez inclure dans votre
distribution :

```toml title="pyproject.toml"
[tool.setuptools]
packages = ["mypkg", "mypkg.subpkg1", "mypkg.subpkg2"]
```

Heureusement `setuptools` poss√®de une
[fonctionnalit√© de d√©couverte](https://setuptools.pypa.io/en/latest/userguide/package_discovery.html) automatique de vos
packages et sous-packages. Celle-ci est compatible avec deux layout projets classique :

le layout dit √† plat (flat-layout) :

```txt title="flat-layout"
count_package
‚îú‚îÄ‚îÄ count_package
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ count_lines.py
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îî‚îÄ‚îÄ test_count_lines.py
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE.md
‚îî‚îÄ‚îÄ README.md
```

et le layout avec un dossier src (src-layout) :

```txt title="src-layout"
projet_genial
‚îú‚îÄ‚îÄ src
|   ‚îú‚îÄ‚îÄ count_package
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ count_lines.py
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îî‚îÄ‚îÄ test_count_lines.py
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE.md
‚îî‚îÄ‚îÄ README.md
```

La diff√©rence peut para√Ætre minime mais personnellement j'ai une grosse pr√©f√©rence pour le src-layout car cela emp√™che
de prendre des mauvaises habitudes et cela force √† comprendre comment le syst√®me d'import et d'installation de package
fonctionne en python.

En effet, lorsque vous d√©veloppez votre package vous tester au fur et √† mesure les fonctionnalit√©s que vous ajoutez √†
celui-ci.

Pour ce faire, on est tr√®s tent√© de simplement importer notre package depuis notre fichier de test :

```python title="test_file.py"
from count_package import count_lines
```

Cela fonctionnera si vous utilisez un flat-layout et que vous ex√©cuter votre module de test depuis le r√©pertoire qui
contient le dossier `count_package` car comme on l'a vu plus haut python inclus le r√©pertoire courant dans a liste des
r√©pertoire o√π il recherche les modules.

Cependant c'est une mauvaise habitude pour deux raisons :

-   D'abord, si vous utilisez setup.py, celui-ci se trouvant √† la racine de votre projet, il est en capacit√© d'importer le
    package `count_package` qu'il est cens√© install√© chez un client en mode sdist ce qui peut provoquer des bugs si on ne
    fait pas attention.
-   Ensuite, **vous ne testez pas vraiment le package tel qu'il sera install√© chez les autres** ! En effet, il se peut
    par exemple que vous n'ayez pas pens√© √† inclure des fichiers de donn√©es dans votre fichier de configuration et vos
    tests devraient en cons√©quence planter. Mais comme ces fichiers sont pr√©sents chez vous, vous vous ne apercevez de
    rien.

Pour ces raisons, je pense qu'il est pr√©f√©rable d'opter pour un src-layout et d'utiliser une
[installation editable](https://setuptools.pypa.io/en/latest/userguide/development_mode.html) gr√¢ce √† la commande :
`pip install -e .` pour le d√©veloppement local. Cela permet d'installer le package en faisant un lien symbolique avec
votre code afin que les modifications que vous y apportez soient imm√©diatement r√©percut√©es sur le package install√©.

Pour une analyse approfondie des avantages du src-layout, je vous renvoie √†
[cet article](https://blog.ionelmc.ro/2014/05/25/python-packaging/#the-structure) (qui date de 2014).

## Les Alernatives √† setuptools

Il existe aujourd'hui des alternatives solides √† setuptools, en voici une liste non exhaustive :

-   [Flit](https://flit.pypa.io/en/stable/) : met l'accent sur la simplicit√© d'utilisation et de configuration.
-   [Pipenv](https://pipenv.pypa.io/en/latest/) : permet de g√©rer conjointement l'environnement virtuel de son projet et
    ses d√©pendances. Ajoute de plus une fonctionnalit√© tr√®s appr√©ciable : la g√©n√©ration de fichiers `Pipfile.lock` qui
    r√©f√©rence des versions exacte des d√©pendances pour permettre la reproduction √† l'identique de l'environnement de
    d√©veloppement.
    ![Gif montrant les fonctionnalit√©s de pipenv](https://gist.githubusercontent.com/jlusk/855d611bbcfa2b159839db73d07f6ce9/raw/7f5743401809f7e630ee8ff458faa980e19924a0/pipenv.gif)
-   [Poetry](https://python-poetry.org/) : outil tr√®s puissant qui permet √† la fois de g√©rer les environnements
    virtuels, les d√©pendances (et les d√©pendances des d√©pendances), de g√©n√©rer un fichier `poetry.lock` similaire √†
    `Pipfile.lock`, de publier son package, etc.
    ![Gif montrant les fonctionnalit√©s de poetry](https://raw.githubusercontent.com/python-poetry/poetry/master/assets/install.gif)

Je trouve pour ma part que [Poetry](https://python-poetry.org/) est l'outil le plus prometteur au vu de sa capacit√© √†
r√©soudre les conflits entre les d√©pendances.

## TL;DR Packager son code python en 2023

Mes conseils pour packager votre code en 2023 :

-   Utilisez le fichier [pyproject.toml](https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html) en
    suivant [le guide setuptools](https://setuptools.pypa.io/en/latest/userguide/quickstart.html).
-   Un petit coup de `pip install build && python -m build` et votre package est pr√™t √† √™tre distribu√©.
-   Adoptez le src-layout.

En bonus :

-   Essayez [Poetry](https://python-poetry.org/).
-   Utilisez [ce template `cookie-cutter`](https://github.com/h4c5/cookie-python-minimal) tout simple (ou cr√©ez le
    votre) pour vos projets.

### Estimons nous heureuses et heureux

Tout ce que je vous ai racont√© ici peut sembler beaucoup et pourtant je n'ai fait que survoler le sujet. En tout cas je
pense que l'on peut s'estimer heureuses et heureux lorsque l'on voit ce qu'√©crivait le site Sam & Max en 2018 :

> D'abord on a `distutils`, `setuptools`, `distribute`, and `distribute2` qui ont tous √©t√© √† un moment les "standards"
> recommand√©s pour packager une lib. Ensuite on a eu l'√©poque des `eggs`, `exe`, et autres trucs que `easy_install`
> allait chercher n'importe o√π dans la nature en suivant aveugl√©ment des liens sur PyPi. Sans compter les machins qu'il
> fallait compiler √† tout bout de champ. Et puis rien n'√©tait chiffr√© au download, `pip` n'√©tait pas packag√© avec
> Python, il crevait sur des erreurs stupides type encodage mal g√©r√©...
>
> √Ä √ßa se rajoute que `virtualenv` √©tait un truc √† part, avec plein de concurrents, et linkait les packages syst√®me par
> d√©faut. Sans oublier qu'on avait pas `python -m`.
>
> Bref, le packaging Python, √ßa a √©t√© vraiment la merde. Avec en plus une doc de merde.

C'est quand m√™me beaucoup plus simple aujourd'hui.

## R√©f√©rences

1.  Le Guide de pypa sur le packaging python :
    [An Overview of Packaging for Python](https://packaging.python.org/en/latest/overview/)
2.  Un article pour comprendre les wheels :
    [What Are Python Wheels and Why Should You Care?](https://realpython.com/python-wheels/#python-packaging-made-better-an-intro-to-python-wheels)
3.  Une s√©rie de trois articles tr√®s √©clairant sur le fonctionnement du packaging python, √©crit par Bern√°t G√°bor en
    2019 :
    -   [The state of Python Packaging](https://bernat.tech/posts/pep-517-and-python-packaging/)
    -   [Python Packaging - Past, Present, Future](https://bernat.tech/posts/pep-517-518/)
    -   [Python packaging - Growing Pains](https://bernat.tech/posts/growing-pain/)
4.  Un article √† la gloire de `setup.cfg` sur le regrett√© site Sam & Max :
    [√† propos de setup.cfg](https://sametmax2.com/vive-setup-cfg-et-mort-a-pyproject-toml/index.html)
5.  Question stackoverflow :
    [What is pyproject.toml file for](https://stackoverflow.com/questions/62983756/what-is-pyproject-toml-file-for)

<Giscus />
